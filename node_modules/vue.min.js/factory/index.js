import {createApp, toRefs, ref, reactive, onMounted, onUnmounted, onUpdated, computed, watch, watchEffect, inject} from "vue";
import {useRoute, useRouter, createRouter, createWebHistory, createWebHashHistory} from "vue-router";
import {createStore, useStore} from "vuex";
import {createPinia, defineStore} from "pinia";

function proto () {}
function route () { return useRoute (); }
function router () { return useRouter (); }
router.slot = function (... slot) { return next.router (... slot); }
router.create = createRouter;
router.history = createWebHistory;
router.hash = {tag: createWebHashHistory}
router.try = {catch: "/:catchAll(.*)"}

function library () {}
function emit (key, ... value) { if ("list" in Function.event) if (Function.event.list [key]) for (var i in Function.event.list [key]) Function.event.list [key][i].call (null, ... value); }
function on (key, value) {
	if (key === "mount") return onMounted (value);
	if (key === "un:mount") return onUnmounted (value);
	if (key === "update") return onUpdated (value);
	if ("list" in Function.event) { if ((key in Function.event.list) === false) Function.event.list [key] = []; Function.event.list [key].push (value); }
	}
on.line = function (line) { if (line === "reference") return on.line.data; else if (arguments.length) return on.line.data.value = line; else return on.line.data.value; }
on.line.data = ref (true);
on.progress = function (progress) { if (progress === "reference") return on.progress.data; else return on.progress.data.value.length; }
on.progress.insert = function (progress, context) { on.progress.data.value.push (progress); if (context) context (); }
on.progress.delete = function (progress) { on.progress.data.value = on.progress.data.value.delete ("progress"); on.progress.data.value = on.progress.data.value.delete (progress); }
on.progress.data = ref (["progress"]);
on.loading = function (loading) { if (loading === "reference") return on.loading.data; else return on.loading.data.value.length; }
on.loading.insert = function (loading, context) { on.loading.data.value.push (loading); if (context) context (); }
on.loading.delete = function (loading) { on.loading.data.value = on.loading.data.value.delete (loading); }
on.loading.data = ref ([]);

function properties (app, key, value) { app.config.globalProperties [key] = value; }
function slot (proto) { return proto.$slots; }
slot.value = function (proto) { return proto.$slots.default; }
function layout (... slot) { return next.layout (... slot); }
function component (... slot) { return next.component (... slot); }
function element (... slot) { return next.element (... slot); }

function respond () {}
function response () {}
function request () {}
request.get = function (... param) { return library.axios.get (... param); }
request.post = function (... param) { return library.axios.post (... param); }

function reference (input = null) { return ref (input); }
function react (key, value) { for (var i in value) key [i] = value [i]; return key; }
react.clear = function (reactor) { for (var i in reactor) delete reactor [i]; }

function v_model (model, ... value) { if (value.length) return v_model.data [v_model.format (model)] = value [0]; else if (model = v_model.data [v_model.format (model)]) return model; else return ""; }
v_model.format = function (model) { var prefix = ("vue.model") + ("."); if ((model = model || "*").toString ().startsWith (prefix)) return model.substr (prefix.length); return model; }
v_model.delete = function (model) { return delete v_model.data [v_model.format (model)]; }
v_model.clear = function (model) { if (model) { if (Array.isArray (model)) for (var i in model) v_model.delete (model [i]); else v_model.delete (model); } else for (var i in v_model.data) delete v_model.data [i]; }
v_model.get = function (model) { return v_model.data [v_model.format (model)] }
v_model.data = reactive ({})

function store (... x) { return store.state (... x); }
store.data = function (driver) { if (driver === "pinia") return createPinia (); else return createStore ({strict: true, state: {dummy: []}, mutations: {mutation (state, context) { context.call (null, state); }}}); }
store.use = function (driver) { if (driver === "pinia") return defineStore ("pinia", {state: function () { return {dummy: []} }, actions: {mutation (context) { context.call (null, this); }}}) (); else return useStore (); }

function proc (context) {
	request.url = context.BASE_URL;
	proc.mode = context.MODE;
	}

function next (vue, composition) {
	if (vue.router) vue.id = "__router__" + vue.router;
	if (vue.layout) vue.id = "__layout__" + vue.layout;
	if (vue.component) vue.id = "__component__" + vue.component;
	if (vue.element) vue.id = "__element__" + vue.element;
	return {
		name: (vue.id || vue.name || Math.random ().toString ()),
		props: (vue.prop || vue.properties || vue.param || vue.parameter || vue.attribute || []),
		setup (properties) { if (vue.setup) return vue.setup.call (this, properties); return {}; },
		mounted () { if (vue.mount) vue.mount.call (this); if (composition) if (composition.mount) composition.mount.call (this); },
		unmounted () { if (vue.eject) vue.eject.call (this); if (composition) if (composition.eject) composition.eject.call (this); },
		created () { if (vue.create) vue.create.call (this); if (composition) if (composition.create) composition.create.call (this); },
		updated () { if (vue.update) vue.update.call (this); if (composition) if (composition.update) composition.update.call (this); },
		watch: vue.watch,
		methods: vue.method,
		}
	}

function v__watch () { watch (... arguments); }
function v_watch (key, value) { var arg = Function.argument (... arguments); watch (key, arg.function, arg.object); }
v_watch.effect = function () { watchEffect (... arguments); }
v_watch.on = function (v, key, value, deep) { if (v) value.call (); watch (key, value, {deep}); }

next.router = function (vue) { vue.router = vue.id || vue.name || vue.router; return next (vue); }
next.layout = function (vue) { vue.layout = vue.id || vue.name || vue.layout; return next (vue); }
next.component = function (vue) { vue.component = vue.id || vue.name || vue.component; return next (vue); }
next.element = function (vue) { vue.element = vue.id || vue.name || vue.element; return next (vue); }

export default {
	proto,
	application: createApp,
	properties, to: {reference: toRefs}, reference, react, reactive: function (input = {}) { return reactive (input); },
	compute: computed, watch: v_watch, inject, store, model: v_model,
	route, router,
	library, on, emit,
	process: proc, request, response, respond,
	slot, layout, component, element,
	directive: function (app, directive, context) {
		if (Object.is.function (context)) app.directive (directive, {beforeMount: context, updated: context});
		else app.directive (directive, {beforeMount: context.mount, updated: context.update});
		},
	next,
	}
