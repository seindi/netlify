require ("core.min.js")
var lib = require ("core.min.js/src")
var $$$ = require ("vue.min.js/library/package.vue")
const {define, echo} = lib
const {zero, one} = lib

define ($$$.vue).function ("socket", function (request, response) {
	if (this.request.parse_url)
		if (this.setup (lib.hash.shuffle ()))
			if (this.fire.wall () === false)
				if (this.is.access.socket (this.socket))
					if (this.is.access.processor (this.socket))
						if (this.request.cross.over = true)
							if (this.token)
								return this.io = true
							else echo ("socket:error", {socket: {id: this.socket.id}, status: "token"})
						else echo ("socket:error", {socket: {id: this.socket.id}, status: "cross:over"})
					else echo ("socket:error", {socket: {id: this.socket.id}, status: "cross:over"})
				else echo ("socket:error", {socket: {id: this.socket.id}, status: "cross:origin"})
			else echo ("socket:error", {socket: {id: this.socket.id}, status: "fire:wall/ip"})
		else echo ("socket:error", {socket: {id: this.socket.id}, status: "setup"})
	else echo ("socket:error", {socket: {id: this.socket.id}, status: "parse_url"})
	})

define ($$$.vue.socket).function ("request", function (request) {
	if (request.data) if (lib.is.object (request.data)) return true
	})

define ($$$.vue.socket).function ("response", function (vue, socket, next) {
	return function (request, response) {
		$$$.vue.emit ("response:prepare", request, response, next, vue)
		socket.value.call (vue, request, response, next, vue)
		}
	})

define ($$$.vue).function ("on", function (vue, event, context) {
	vue.socket.on (event, function (prop) {
		if (lib.is.object (prop)) {
			if (vue.is.tokenizer (prop)) {
				if (prop.context) {
					if ($$$.vue.routine.call (vue)) {
						context.call ({context: {id: prop.context.id, session: prop.context.session}}, $$$.vue.on.request (vue, event, prop), $$$.vue.on.response (vue, event, prop))
						}
					}
				}
			}
		})
	return vue
	})

define ($$$.vue.on).set ("data", {})
define ($$$.vue.on).function ("emit", function (key, value) { return $$$.vue.on.data [key] = value })

define ($$$.vue.on).function ("request", function (vue, event, prop) {
	var test
	let testing
	const request = {
		data: prop.data,
		function: function () {},
		prop: function () { if (prop) if (lib.is.object (prop)) return lib.is.object (prop.data) },
		string: function () { if (prop) if (lib.is.object (prop)) return lib.is.string (prop.data) },
		}
	return request
	})

define ($$$.vue.on).function ("response", function (vue, event, prop) {
	var test
	let testing
	const response = function (data) {
		if ($$$.app.delay) lib.date.sleep (function () { vue.socket.emit (event, {context: {id: prop.context.id, session: prop.context.session}, data: data}) }, $$$.app.delay)
		else vue.socket.emit (event, {context: {id: prop.context.id, session: prop.context.session}, data: data})
		}
	response.state = function (event, data) {
		if ($$$.app.delay) lib.date.sleep (function () { vue.socket.emit (event, {context: {id: prop.context.id, session: prop.context.session}, data: data}) }, $$$.app.delay)
		else vue.socket.emit (event, {context: {id: prop.context.id, session: prop.context.session}, data: data})
		}
	response.all = function (data) {
		if ($$$.app.delay) lib.date.sleep (function () { vue.socket.io [("socket").concat ("s")].emit (event, {context: {id: prop.context.id, session: prop.context.session}, data: data}) }, $$$.app.delay)
		else vue.socket.io [("socket").concat ("s")].emit (event, {context: {id: prop.context.id, session: prop.context.session}, data: data})
		}
	response.broadcast = function (data) {
		if ($$$.app.delay) lib.date.sleep (function () { vue.socket.broadcast.emit (event, {context: {id: prop.context.id, session: prop.context.session}, data: data}) }, $$$.app.delay)
		else vue.socket.broadcast.emit (event, {context: {id: prop.context.id, session: prop.context.session}, data: data})
		}
	response.error = function (error = true) {
		response ({error})
		}
	return response
	})
