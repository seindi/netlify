require ("core.min.js")
var lib = require ("core.min.js/src")
var $$$ = require ("vue.min.js/library/package.vue")
const {define, echo} = lib
const {zero, one} = lib

define ($$$.vue).function ("process", function (request, response, next) {
	next ()
	})

define ($$$.vue).function ("socket", function (request, response) {
	if (this.request.parse_url)
		if (this.setup ())
			if (this.fire.wall () === false)
				if (this.is.access.socket (this.socket))
					if (this.is.access.processor (this.socket))
						if (this.request.cross.over = true)
							if (this.token)
								return this.io = true
							else console.log ("socket:error", {socket: {id: this.socket.id}, status: "token"})
						else console.log ("socket:error", {socket: {id: this.socket.id}, status: "cross:over"})
					else console.log ("socket:error", {socket: {id: this.socket.id}, status: "cross:processor"})
				else console.log ("socket:error", {socket: {id: this.socket.id}, status: "cross:origin"})
			else console.log ("socket:error", {socket: {id: this.socket.id}, status: "fire:wall/ip"})
		else console.log ("socket:error", {socket: {id: this.socket.id}, status: "setup"})
	else console.log ("socket:error", {socket: {id: this.socket.id}, status: "parse_url"})
	})

define ($$$.vue.socket).function ("request", function (request) {
	if (request.data) if (lib.is.object (request.data)) return true
	})

define ($$$.vue.socket).function ("response", function (vue, socket) {
	return function (request, response) {
		socket.value.call ({vue}, request, response)
		}
	})

define ($$$.vue).function ("on", function (vue, event, context) {
	vue.socket.on (event, function (prop) {
		if (lib.is.object (prop)) {
			if (vue.is.tokenizer (prop)) {
				if (prop.context) {
					if ($$$.vue.routine.call ({vue})) {
						context.call ({context: {id: prop.context.id, session: prop.context.session, tokenizer: prop.context.tokenizer}}, $$$.vue.on.request (vue, event, prop), $$$.vue.on.response (vue, event, prop))
						}
					}
				}
			}
		})
	return vue
	})

define ($$$.vue.on).set ("data", {})
define ($$$.vue.on).function ("emit", function (key, value) { return $$$.vue.on.data [key] = value })

define ($$$.vue.on).function ("request", function (vue, event, prop) {
	var test
	let testing
	const request = {
		from: null,
		data: prop.data, path: "/", slug: {}, query: {},
		visitor: vue.request.visitor,
		function: function () {},
		prop: function () { if (prop) if (lib.is.object (prop)) return lib.is.object (prop.data) },
		string: function () { if (prop) if (lib.is.object (prop)) return lib.is.string (prop.data) },
		}
	return request
	})

define ($$$.vue.on).function ("response", function (vue, event, prop) {
	var test
	let testing
	const response = function (data) {
		if ($$$.app.delay) lib.date.sleep (function () { vue.socket.emit (event, {context: {id: prop.context.id, session: prop.context.session}, data: data}) }, $$$.app.delay)
		else vue.socket.emit (event, {context: {id: prop.context.id, session: prop.context.session}, data: data})
		}
	response.state = function (event, data) {
		if ($$$.app.delay) lib.date.sleep (function () { vue.socket.emit (event, {context: {id: prop.context.id, session: prop.context.session}, data: data}) }, $$$.app.delay)
		else vue.socket.emit (event, {context: {id: prop.context.id, session: prop.context.session}, data: data})
		}
	response.all = function (data) {
		if ($$$.app.delay) lib.date.sleep (function () { vue.socket.io [("socket").concat ("s")].emit (event, {context: {id: prop.context.id, session: prop.context.session}, data: data}) }, $$$.app.delay)
		else vue.socket.io [("socket").concat ("s")].emit (event, {context: {id: prop.context.id, session: prop.context.session}, data: data})
		}
	response.broadcast = function (data) {
		if ($$$.app.delay) lib.date.sleep (function () { vue.socket.broadcast.emit (event, {context: {id: prop.context.id, session: prop.context.session}, data: data}) }, $$$.app.delay)
		else vue.socket.broadcast.emit (event, {context: {id: prop.context.id, session: prop.context.session}, data: data})
		}
	response.error = function (error = true) {
		response ({error})
		}
	return response
	})

define ($$$.vue.on).function ("pipe", function (vue, router, r, option) {
	return function (request, response) {
		request.from = "socket"
		vue.app.session.reload (true)
		var error = true
		var try_catch = true
		var next = function () {
			return this
			}
		var post = function (key, value) {
			if (arguments.length > one) return data [key] = value
			else if (key in data) return lib.to.string (data [key])
			else return ""
			}
		var db = function () {}
		db.single = function (db) {
			db.data = db.data [zero]
			return response (db)
			}
		option = option || {method: "pipe"}
		var path = request.data.path
		var query = request.data.query
		var data = request.data ["data"] || {}
		var file = data.file
		request.method = request.data.method || option.method || "pipe"
		request.path = path
		request.query = query
		request.file = file
		request.data = data
		request.post = post
		response.db = db
		delete request.data.file
		if (lib.is.array (router)) {
			for (var i in router) {
				if (router [i].method === request.method) {
					var regex = lib.regex.path (path, router [i].url)
					if (regex.match) {
						request.slug = regex.param
						router [i].context.call ({vue}, request, response, next)
						try_catch = null
						}
					}
				}
			}
		if (try_catch) {
			for (var i in r) {
				if (r [i].url === "*") {
					r [i].context.call ({vue}, request, response, next)
					error = null
					}
				}
			if (error) {
				if ($$$.app.delay) lib.time.sleep (function () { response.error () }, $$$.app.delay)
				else response.error ()
				}
			}
		}
	})

define ($$$.vue.on).function ("link", function (vue, router, r) {
	return $$$.vue.on.pipe (vue, router, r, {method: "get"})
	})

define ($$$.vue).function ("request", function (request) {
	if (request.data) if (lib.is.object (request.data)) return true
	})

define ($$$.vue).function ("response", function (vue, router) {
	return function (request, response, next) {
		router.context.call ({vue}, request, response, next)
		}
	})

define ($$$.vue.response).function ("promise", function (vue, router) {
	return function (request, response, next) {
		var promise = new lib.promise (function (resolve, reject) {
			vue.app.session.reload ()
			var r = {from: "tcp", data: request.parse_url, slug: {}}
			var response = function (data) { resolve ({type: "vue", data}) }
			response.css = function (data) { resolve ({type: "css", data}) }
			response.json = function (data) { resolve ({type: "json", data}) }
			response.xml = function (data) { resolve ({type: "xml", data}) }
			response.error = function (data) { resolve ({type: "vue", data: lib.object.assign ({error: "found"}, data)}) }
			response.reject = function (data) { reject (data) }
			if ((router.url === "*") === false) r.slug = lib.regex.path (r.data.path, router.url).param
			router.context.call ({vue}, r, response, next)
			})
		promise.then ($$$.vue.response.promise.finally (vue, request, response, next))
		promise.catch (function () { next () })
		}
	})

define ($$$.vue.response.promise).function ("finally", function (vue, request, response, next) {
	return function (respond) {
		if (lib.is.object (respond)) {
			var size_of = function () {
				vue.size_of.push (request.path, lib.json.format (respond.data).length, {type: "request"})
				}
			if (respond.type === "vue") size_of (), vue.render (request, respond.data)
			else if (respond.type === "css") response.css (respond.data)
			else if (respond.type === "json") response.json (respond.data)
			else if (respond.type === "xml") response.xml (respond.data)
			else if (respond.type === "render") response.render (respond.render, respond.data)
			else response.send (respond.data)
			}
		else response.end ()
		}
	})
