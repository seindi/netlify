require ("core.min.js")
var lib = require ("core.min.js/src")
var $$$ = require (lib.package ("vue.min.js"))
const {define, echo} = lib
const {zero, one} = lib
var link = true

define (module).export (function (io) {
	return function (socket) {
		$$$.app.start (socket.io = io)
		const request = $$$.express.request ({socket, package: $$$.app.package})
		const response = function (key, value) { socket.emit (key, value) }
		const vue = new $$$.vue ((new $$$.vue.app), request, response, socket)
		const the = new setup (vue, socket, request, response)
		if ($$$.vue.socket.call (vue, request, response)) {
			if ("socket") {
				echo ("socket:open", {socket: {id: socket.id}})
				socket.on (lib.web.socket.close, function () {
					echo ("socket:close", {socket: {id: socket.id}})
					})
				}
			if (the.continue) the.io ()
			}
		}
	})

class setup {
	constructor (vue, socket, request, response) {
		this.continue = true
		this.vue = vue
		this.socket = socket
		this.request = request
		this.response = response
		}
	io () { return setup.io (this.vue, this.socket, this.request, this.response) }
	process () { return setup.process (this.vue, this.socket, this.request, this.response) }
	}

setup.io = function (vue, socket, request, response) {
	const db = vue.data.base ("app").then (function (client) {
		vue.app.db = client.use (client.connection.name)
		vue.tokenizer = lib.hash.shuffle ()
		if (vue.data.cache ()) {
			setup.process (vue, socket, request, response)
			socket.emit ("tokenizer", vue.tokenizer)
			}
		else vue.app.db.setup (function () {
			if (vue.data.create ()) {
				setup.process (vue, socket, request, response)
				socket.emit ("tokenizer", vue.tokenizer)
				}
			})
		})
	db.catch ()
	}

setup.process = function (vue, socket, request, response) {
	if ($$$.app.setting ["db:socket"]) {
		vue.on ("db:select", function (request, response) { vue.db.select ((request.io = vue.db.parameter (request.data)).collection).from (request.io.data.base).meta (request.io.meta).on (... request.io.on).sort (... request.io.sort).limit (... request.io.limit).then (function (db) { response (db) }).catch ($$$.express.error (response)) })
		vue.on ("db:insert", function (request, response) { vue.db.insert ((request.io = vue.db.parameter (request.data)).collection).from (request.io.data.base).set (request.io.data.entry).then (function (db) { response (db) }).catch ($$$.express.error (response)) })
		vue.on ("db:update", function (request, response) { vue.db.update ((request.io = vue.db.parameter (request.data)).collection).from (request.io.data.base).set (request.io.data.entry).on (... request.io.on).sort (... request.io.sort).limit (... request.io.limit).then (function (db) { response (db) }).catch ($$$.express.error (response)) })
		vue.on ("db:delete", function (request, response) { vue.db.delete ((request.io = vue.db.parameter (request.data)).collection).from (request.io.data.base).on (... request.io.on).sort (... request.io.sort).limit (... request.io.limit).then (function (db) { response (db) }).catch ($$$.express.error (response)) })
		vue.on ("db:dump", function (request, response) { vue.data.base.dump (request.data, response) })
		vue.on ("db:setup", function (request, response) {
			vue.data.base.setup (request, response)
			response ()
			})
		}
	if (link) {
		var the
		if (the = vue.require ()) {
			for (var i in the.socket.on) vue.on (the.socket.on [i].key, $$$.vue.socket.response (vue, the.socket.on [i]))
			vue.on ("broadcast", function (request, response) { response.broadcast ("broadcast", request.data) })
			vue.on ("pipe", $$$.vue.on.pipe (vue, the.router, the.try))
			vue.on ("link", $$$.vue.on.link (vue, the.router, the.try))
			}
		}
	else {
		var the = vue.require ()
		if (the) {
			for (var i in the.socket.on) vue.on (the.socket.on [i].key, $$$.vue.socket.response (vue, the.socket.on [i]))
			vue.on ("broadcast", function (request, response) { response.broadcast ("broadcast", request.data) })
			}
		}
	}
